{"ast":null,"code":"import _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\nimport fetch from 'isomorphic-unfetch';\nimport { Environment, Network, RecordSource, Store } from 'relay-runtime';\nvar relayEnvironment = null; // Define a function that fetches the results of an operation (query/mutation/etc)\n// and returns its results as a Promise:\n\nfunction fetchQuery( // @ts-ignore\noperation, // @ts-ignore\nvariables, // @ts-ignore\ncacheConfig, // @ts-ignore\nuploadables) {\n  // Because we implement the graphql server, the client must to point to the same host\n  // @ts-ignore\n  var relayServer = process.browser ? '' : process.env.GRAPHQL_URL;\n  return fetch(\"\".concat(relayServer), {\n    method: 'POST',\n    headers: {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json'\n    },\n    // Add authentication and other headers here\n    body: _JSON$stringify({\n      query: operation.text,\n      // GraphQL text from input\n      variables: variables\n    })\n  }).then(function (response) {\n    return response.json();\n  });\n}\n\nexport default function initEnvironment() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$records = _ref.records,\n      records = _ref$records === void 0 ? {} : _ref$records;\n\n  // Create a network layer from the fetch function\n  var network = Network.create(fetchQuery);\n  var store = new Store(new RecordSource(records)); // Make sure to create a new Relay environment for every server-side request so that data\n  // isn't shared between connections (which would be bad)\n  // @ts-ignore\n\n  if (!process.browser) {\n    return new Environment({\n      network: network,\n      store: store\n    });\n  } // reuse Relay environment on client-side\n\n\n  if (!relayEnvironment) {\n    relayEnvironment = new Environment({\n      network: network,\n      store: store\n    });\n  }\n\n  return relayEnvironment;\n}","map":{"version":3,"sources":["/Users/rafael/Projetos/bastiani-blog/relay/createRelayEnvironment.ts"],"names":["fetch","Environment","Network","RecordSource","Store","relayEnvironment","fetchQuery","operation","variables","cacheConfig","uploadables","relayServer","process","browser","env","GRAPHQL_URL","method","headers","body","query","text","then","response","json","initEnvironment","records","network","create","store"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,oBAAlB;AACA,SAASC,WAAT,EAAsBC,OAAtB,EAA+BC,YAA/B,EAA6CC,KAA7C,QAA0D,eAA1D;AAEA,IAAIC,gBAAoC,GAAG,IAA3C,C,CAEA;AACA;;AACA,SAASC,UAAT,EACE;AACAC,SAFF,EAGE;AACAC,SAJF,EAKE;AACAC,WANF,EAOE;AACAC,WARF,EASE;AACA;AACA;AACA,MAAMC,WAAW,GAAGC,OAAO,CAACC,OAAR,GAAkB,EAAlB,GAAuBD,OAAO,CAACE,GAAR,CAAYC,WAAvD;AACA,SAAOf,KAAK,WAAIW,WAAJ,GAAmB;AAC7BK,IAAAA,MAAM,EAAE,MADqB;AAE7BC,IAAAA,OAAO,EAAE;AACP,gBAAU,kBADH;AAEP,sBAAgB;AAFT,KAFoB;AAK1B;AACHC,IAAAA,IAAI,EAAE,gBAAe;AACnBC,MAAAA,KAAK,EAAEZ,SAAS,CAACa,IADE;AACI;AACvBZ,MAAAA,SAAS,EAATA;AAFmB,KAAf;AANuB,GAAnB,CAAL,CAUJa,IAVI,CAUC,UAACC,QAAD;AAAA,WAAcA,QAAQ,CAACC,IAAT,EAAd;AAAA,GAVD,CAAP;AAWD;;AAED,eAAe,SAASC,eAAT,GAAgD;AAAA,iFAAJ,EAAI;AAAA,0BAArBC,OAAqB;AAAA,MAArBA,OAAqB,6BAAX,EAAW;;AAC7D;AACA,MAAMC,OAAO,GAAGxB,OAAO,CAACyB,MAAR,CAAerB,UAAf,CAAhB;AACA,MAAMsB,KAAK,GAAG,IAAIxB,KAAJ,CAAU,IAAID,YAAJ,CAAiBsB,OAAjB,CAAV,CAAd,CAH6D,CAK7D;AACA;AACA;;AACA,MAAI,CAACb,OAAO,CAACC,OAAb,EAAsB;AACpB,WAAO,IAAIZ,WAAJ,CAAgB;AACrByB,MAAAA,OAAO,EAAPA,OADqB;AAErBE,MAAAA,KAAK,EAALA;AAFqB,KAAhB,CAAP;AAID,GAb4D,CAe7D;;;AACA,MAAI,CAACvB,gBAAL,EAAuB;AACrBA,IAAAA,gBAAgB,GAAG,IAAIJ,WAAJ,CAAgB;AACjCyB,MAAAA,OAAO,EAAPA,OADiC;AAEjCE,MAAAA,KAAK,EAALA;AAFiC,KAAhB,CAAnB;AAID;;AAED,SAAOvB,gBAAP;AACD","sourcesContent":["import fetch from 'isomorphic-unfetch';\nimport { Environment, Network, RecordSource, Store } from 'relay-runtime';\n\nlet relayEnvironment: Environment | null = null;\n\n// Define a function that fetches the results of an operation (query/mutation/etc)\n// and returns its results as a Promise:\nfunction fetchQuery(\n  // @ts-ignore\n  operation,\n  // @ts-ignore\n  variables,\n  // @ts-ignore\n  cacheConfig,\n  // @ts-ignore\n  uploadables,\n) {\n  // Because we implement the graphql server, the client must to point to the same host\n  // @ts-ignore\n  const relayServer = process.browser ? '' : process.env.GRAPHQL_URL;\n  return fetch(`${relayServer}`, {\n    method: 'POST',\n    headers: {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json',\n    }, // Add authentication and other headers here\n    body: JSON.stringify({\n      query: operation.text, // GraphQL text from input\n      variables,\n    }),\n  }).then((response) => response.json());\n}\n\nexport default function initEnvironment({ records = {} } = {}) {\n  // Create a network layer from the fetch function\n  const network = Network.create(fetchQuery);\n  const store = new Store(new RecordSource(records));\n\n  // Make sure to create a new Relay environment for every server-side request so that data\n  // isn't shared between connections (which would be bad)\n  // @ts-ignore\n  if (!process.browser) {\n    return new Environment({\n      network,\n      store,\n    });\n  }\n\n  // reuse Relay environment on client-side\n  if (!relayEnvironment) {\n    relayEnvironment = new Environment({\n      network,\n      store,\n    });\n  }\n\n  return relayEnvironment;\n}\n"]},"metadata":{},"sourceType":"module"}